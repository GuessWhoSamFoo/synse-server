// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	ReadRequest
	WriteRequest
	MetainfoRequest
	TransactionId
	ReadResponse
	MetainfoResponse
	WriteResponse
	MetaOutputUnit
	MetaOutputRange
	MetaOutput
	MetaLocation
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ReadingType int32

const (
	ReadingType_UNKNOWN               ReadingType = 0
	ReadingType_TEMPERATURE           ReadingType = 1
	ReadingType_DIFFERENTIAL_PRESSURE ReadingType = 2
	ReadingType_AIRFLOW               ReadingType = 3
	ReadingType_HUMIDITY              ReadingType = 4
	ReadingType_LED_STATE             ReadingType = 5
	ReadingType_LED_BLINK             ReadingType = 6
)

var ReadingType_name = map[int32]string{
	0: "UNKNOWN",
	1: "TEMPERATURE",
	2: "DIFFERENTIAL_PRESSURE",
	3: "AIRFLOW",
	4: "HUMIDITY",
	5: "LED_STATE",
	6: "LED_BLINK",
}
var ReadingType_value = map[string]int32{
	"UNKNOWN":               0,
	"TEMPERATURE":           1,
	"DIFFERENTIAL_PRESSURE": 2,
	"AIRFLOW":               3,
	"HUMIDITY":              4,
	"LED_STATE":             5,
	"LED_BLINK":             6,
}

func (x ReadingType) String() string {
	return proto.EnumName(ReadingType_name, int32(x))
}
func (ReadingType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type WriteResponse_WriteStatus int32

const (
	WriteResponse_UNKNOWN WriteResponse_WriteStatus = 0
	WriteResponse_PENDING WriteResponse_WriteStatus = 1
	WriteResponse_WRITING WriteResponse_WriteStatus = 2
	WriteResponse_DONE    WriteResponse_WriteStatus = 3
)

var WriteResponse_WriteStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "WRITING",
	3: "DONE",
}
var WriteResponse_WriteStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"PENDING": 1,
	"WRITING": 2,
	"DONE":    3,
}

func (x WriteResponse_WriteStatus) String() string {
	return proto.EnumName(WriteResponse_WriteStatus_name, int32(x))
}
func (WriteResponse_WriteStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type WriteResponse_WriteState int32

const (
	WriteResponse_OK    WriteResponse_WriteState = 0
	WriteResponse_ERROR WriteResponse_WriteState = 1
)

var WriteResponse_WriteState_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var WriteResponse_WriteState_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x WriteResponse_WriteState) String() string {
	return proto.EnumName(WriteResponse_WriteState_name, int32(x))
}
func (WriteResponse_WriteState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 1} }

// Read
// ~~~~
// the read request message contains the uuid of the device that
// we desire to read. the uuid of the device should be generated
// by the owning background process and should be returned to the
// synse application in the MetainfoResponse, which Synse will
// cache and use as a lookup table for routing requests.
type ReadRequest struct {
	Uid string `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ReadRequest) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

// Write
// ~~~~~
// the write request message contains the uuid of the device that
// we desire to write to, as well as a repeated string (e.g. a
// list of strings in Python) which makes up the data that we
// which to write to that device.
type WriteRequest struct {
	Uid string `protobuf:"bytes,1,opt,name=uid" json:"uid,omitempty"`
	// TODO: should this be string or bytes?
	Data []string `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *WriteRequest) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *WriteRequest) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

// Metainfo
// ~~~~~~~~
// the metainfo request message contains a field for rack and board,
// but neither are required. if specified, the response will contain
// only information relating to the rack/board filter applied. if
// they are left unspecified, the response will contain the entirety
// of the metainfo scan information.
type MetainfoRequest struct {
	Rack  string `protobuf:"bytes,1,opt,name=rack" json:"rack,omitempty"`
	Board string `protobuf:"bytes,2,opt,name=board" json:"board,omitempty"`
}

func (m *MetainfoRequest) Reset()                    { *m = MetainfoRequest{} }
func (m *MetainfoRequest) String() string            { return proto.CompactTextString(m) }
func (*MetainfoRequest) ProtoMessage()               {}
func (*MetainfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MetainfoRequest) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *MetainfoRequest) GetBoard() string {
	if m != nil {
		return m.Board
	}
	return ""
}

// TransactionCheck
// ~~~~~~~~~~~~~~~~
// the transaction id gives identity to a single 'write' action. since
// device writes are handled asynchronously, the background process
// returns the transaction id when a write is registered, which the
// caller can later pass back to `TransactionCheck` to get the status
// of that write.
type TransactionId struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *TransactionId) Reset()                    { *m = TransactionId{} }
func (m *TransactionId) String() string            { return proto.CompactTextString(m) }
func (*TransactionId) ProtoMessage()               {}
func (*TransactionId) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TransactionId) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Read
// ~~~~
// the read response provides the timestamp at which the reading was
// taken, the type of the reading (e.g. temperature, humidity, led
// state, etc.), and the value of that reading. read responses are
// returned to the client as a stream, so a single device can return
// multiple readings. (e.g. a humidity sensor can return a %humidity
// reading and a temperature reading).
type ReadResponse struct {
	Timestamp string      `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Type      ReadingType `protobuf:"varint,2,opt,name=type,enum=ReadingType" json:"type,omitempty"`
	Value     string      `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ReadResponse) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *ReadResponse) GetType() ReadingType {
	if m != nil {
		return m.Type
	}
	return ReadingType_UNKNOWN
}

func (m *ReadResponse) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Metainfo
// ~~~~~~~~
// the metainfo response represents a single device that is owned by
// the process. metainfo responses are returned to the client as a stream
// so a background process can support any number of devices. the response
// itself contains a timestamp for when the response was generated, an
// for the device, and all other meta-information we have pertaining to
// that device. the caller, Synse, will cache this information and use it
// to route requests to the appropriate device as well as provide responses
// for scan and info requests.
type MetainfoResponse struct {
	Timestamp    string        `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Uid          string        `protobuf:"bytes,2,opt,name=uid" json:"uid,omitempty"`
	Type         string        `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
	Model        string        `protobuf:"bytes,4,opt,name=model" json:"model,omitempty"`
	Manufacturer string        `protobuf:"bytes,5,opt,name=manufacturer" json:"manufacturer,omitempty"`
	Protocol     string        `protobuf:"bytes,6,opt,name=protocol" json:"protocol,omitempty"`
	Info         string        `protobuf:"bytes,7,opt,name=info" json:"info,omitempty"`
	Comment      string        `protobuf:"bytes,8,opt,name=comment" json:"comment,omitempty"`
	Location     *MetaLocation `protobuf:"bytes,9,opt,name=location" json:"location,omitempty"`
	Output       []*MetaOutput `protobuf:"bytes,10,rep,name=output" json:"output,omitempty"`
}

func (m *MetainfoResponse) Reset()                    { *m = MetainfoResponse{} }
func (m *MetainfoResponse) String() string            { return proto.CompactTextString(m) }
func (*MetainfoResponse) ProtoMessage()               {}
func (*MetainfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MetainfoResponse) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *MetainfoResponse) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *MetainfoResponse) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MetainfoResponse) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *MetainfoResponse) GetManufacturer() string {
	if m != nil {
		return m.Manufacturer
	}
	return ""
}

func (m *MetainfoResponse) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *MetainfoResponse) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *MetainfoResponse) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *MetainfoResponse) GetLocation() *MetaLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *MetainfoResponse) GetOutput() []*MetaOutput {
	if m != nil {
		return m.Output
	}
	return nil
}

// TransactionCheck
// ~~~~~~~~~~~~~~~~
// the response for a transaction check command gives the status of the
// transaction. transactions correspond to write requests. since writes
// are performed asynchronously, the transaction id is used to track the
// progress of that transaction.
type WriteResponse struct {
	Timestamp string                    `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Status    WriteResponse_WriteStatus `protobuf:"varint,2,opt,name=status,enum=WriteResponse_WriteStatus" json:"status,omitempty"`
	State     WriteResponse_WriteState  `protobuf:"varint,3,opt,name=state,enum=WriteResponse_WriteState" json:"state,omitempty"`
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *WriteResponse) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *WriteResponse) GetStatus() WriteResponse_WriteStatus {
	if m != nil {
		return m.Status
	}
	return WriteResponse_UNKNOWN
}

func (m *WriteResponse) GetState() WriteResponse_WriteState {
	if m != nil {
		return m.State
	}
	return WriteResponse_OK
}

type MetaOutputUnit struct {
	Name   string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Symbol string `protobuf:"bytes,2,opt,name=symbol" json:"symbol,omitempty"`
}

func (m *MetaOutputUnit) Reset()                    { *m = MetaOutputUnit{} }
func (m *MetaOutputUnit) String() string            { return proto.CompactTextString(m) }
func (*MetaOutputUnit) ProtoMessage()               {}
func (*MetaOutputUnit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *MetaOutputUnit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MetaOutputUnit) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

type MetaOutputRange struct {
	Min int32 `protobuf:"varint,1,opt,name=min" json:"min,omitempty"`
	Max int32 `protobuf:"varint,2,opt,name=max" json:"max,omitempty"`
}

func (m *MetaOutputRange) Reset()                    { *m = MetaOutputRange{} }
func (m *MetaOutputRange) String() string            { return proto.CompactTextString(m) }
func (*MetaOutputRange) ProtoMessage()               {}
func (*MetaOutputRange) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *MetaOutputRange) GetMin() int32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *MetaOutputRange) GetMax() int32 {
	if m != nil {
		return m.Max
	}
	return 0
}

type MetaOutput struct {
	Type      string           `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Precision int32            `protobuf:"varint,2,opt,name=precision" json:"precision,omitempty"`
	Unit      *MetaOutputUnit  `protobuf:"bytes,3,opt,name=unit" json:"unit,omitempty"`
	Range     *MetaOutputRange `protobuf:"bytes,4,opt,name=range" json:"range,omitempty"`
}

func (m *MetaOutput) Reset()                    { *m = MetaOutput{} }
func (m *MetaOutput) String() string            { return proto.CompactTextString(m) }
func (*MetaOutput) ProtoMessage()               {}
func (*MetaOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *MetaOutput) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MetaOutput) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *MetaOutput) GetUnit() *MetaOutputUnit {
	if m != nil {
		return m.Unit
	}
	return nil
}

func (m *MetaOutput) GetRange() *MetaOutputRange {
	if m != nil {
		return m.Range
	}
	return nil
}

type MetaLocation struct {
	Rack   string `protobuf:"bytes,1,opt,name=rack" json:"rack,omitempty"`
	Board  string `protobuf:"bytes,2,opt,name=board" json:"board,omitempty"`
	Device string `protobuf:"bytes,3,opt,name=device" json:"device,omitempty"`
}

func (m *MetaLocation) Reset()                    { *m = MetaLocation{} }
func (m *MetaLocation) String() string            { return proto.CompactTextString(m) }
func (*MetaLocation) ProtoMessage()               {}
func (*MetaLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MetaLocation) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *MetaLocation) GetBoard() string {
	if m != nil {
		return m.Board
	}
	return ""
}

func (m *MetaLocation) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func init() {
	proto.RegisterType((*ReadRequest)(nil), "ReadRequest")
	proto.RegisterType((*WriteRequest)(nil), "WriteRequest")
	proto.RegisterType((*MetainfoRequest)(nil), "MetainfoRequest")
	proto.RegisterType((*TransactionId)(nil), "TransactionId")
	proto.RegisterType((*ReadResponse)(nil), "ReadResponse")
	proto.RegisterType((*MetainfoResponse)(nil), "MetainfoResponse")
	proto.RegisterType((*WriteResponse)(nil), "WriteResponse")
	proto.RegisterType((*MetaOutputUnit)(nil), "MetaOutputUnit")
	proto.RegisterType((*MetaOutputRange)(nil), "MetaOutputRange")
	proto.RegisterType((*MetaOutput)(nil), "MetaOutput")
	proto.RegisterType((*MetaLocation)(nil), "MetaLocation")
	proto.RegisterEnum("ReadingType", ReadingType_name, ReadingType_value)
	proto.RegisterEnum("WriteResponse_WriteStatus", WriteResponse_WriteStatus_name, WriteResponse_WriteStatus_value)
	proto.RegisterEnum("WriteResponse_WriteState", WriteResponse_WriteState_name, WriteResponse_WriteState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for InternalApi service

type InternalApiClient interface {
	// Read from the specified device(s).
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (InternalApi_ReadClient, error)
	// Write to the specified device(s).
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*TransactionId, error)
	// Get the metainformation from the background process that describes
	// all of the available devices which that process owns
	Metainfo(ctx context.Context, in *MetainfoRequest, opts ...grpc.CallOption) (InternalApi_MetainfoClient, error)
	// Check on the state of a write transaction.
	TransactionCheck(ctx context.Context, in *TransactionId, opts ...grpc.CallOption) (*WriteResponse, error)
}

type internalApiClient struct {
	cc *grpc.ClientConn
}

func NewInternalApiClient(cc *grpc.ClientConn) InternalApiClient {
	return &internalApiClient{cc}
}

func (c *internalApiClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (InternalApi_ReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InternalApi_serviceDesc.Streams[0], c.cc, "/InternalApi/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalApiReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InternalApi_ReadClient interface {
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type internalApiReadClient struct {
	grpc.ClientStream
}

func (x *internalApiReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalApiClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*TransactionId, error) {
	out := new(TransactionId)
	err := grpc.Invoke(ctx, "/InternalApi/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalApiClient) Metainfo(ctx context.Context, in *MetainfoRequest, opts ...grpc.CallOption) (InternalApi_MetainfoClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_InternalApi_serviceDesc.Streams[1], c.cc, "/InternalApi/Metainfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &internalApiMetainfoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InternalApi_MetainfoClient interface {
	Recv() (*MetainfoResponse, error)
	grpc.ClientStream
}

type internalApiMetainfoClient struct {
	grpc.ClientStream
}

func (x *internalApiMetainfoClient) Recv() (*MetainfoResponse, error) {
	m := new(MetainfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalApiClient) TransactionCheck(ctx context.Context, in *TransactionId, opts ...grpc.CallOption) (*WriteResponse, error) {
	out := new(WriteResponse)
	err := grpc.Invoke(ctx, "/InternalApi/TransactionCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for InternalApi service

type InternalApiServer interface {
	// Read from the specified device(s).
	Read(*ReadRequest, InternalApi_ReadServer) error
	// Write to the specified device(s).
	Write(context.Context, *WriteRequest) (*TransactionId, error)
	// Get the metainformation from the background process that describes
	// all of the available devices which that process owns
	Metainfo(*MetainfoRequest, InternalApi_MetainfoServer) error
	// Check on the state of a write transaction.
	TransactionCheck(context.Context, *TransactionId) (*WriteResponse, error)
}

func RegisterInternalApiServer(s *grpc.Server, srv InternalApiServer) {
	s.RegisterService(&_InternalApi_serviceDesc, srv)
}

func _InternalApi_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalApiServer).Read(m, &internalApiReadServer{stream})
}

type InternalApi_ReadServer interface {
	Send(*ReadResponse) error
	grpc.ServerStream
}

type internalApiReadServer struct {
	grpc.ServerStream
}

func (x *internalApiReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InternalApi_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalApiServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/InternalApi/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalApiServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InternalApi_Metainfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MetainfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalApiServer).Metainfo(m, &internalApiMetainfoServer{stream})
}

type InternalApi_MetainfoServer interface {
	Send(*MetainfoResponse) error
	grpc.ServerStream
}

type internalApiMetainfoServer struct {
	grpc.ServerStream
}

func (x *internalApiMetainfoServer) Send(m *MetainfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _InternalApi_TransactionCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalApiServer).TransactionCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/InternalApi/TransactionCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalApiServer).TransactionCheck(ctx, req.(*TransactionId))
	}
	return interceptor(ctx, in, info, handler)
}

var _InternalApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "InternalApi",
	HandlerType: (*InternalApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _InternalApi_Write_Handler,
		},
		{
			MethodName: "TransactionCheck",
			Handler:    _InternalApi_TransactionCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _InternalApi_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Metainfo",
			Handler:       _InternalApi_Metainfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 770 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x8e, 0x1d, 0x3b, 0x8d, 0x8f, 0x93, 0xd4, 0x8c, 0x00, 0x79, 0xa3, 0x95, 0x1a, 0xcd, 0x4a,
	0x10, 0xb8, 0x30, 0xc8, 0xbb, 0x5c, 0x81, 0x90, 0x02, 0x71, 0xc1, 0x6a, 0xea, 0x44, 0x13, 0x47,
	0x11, 0x57, 0xab, 0xa9, 0x3d, 0xbb, 0x58, 0x1b, 0xff, 0x60, 0x8f, 0x57, 0xed, 0x15, 0x0f, 0xc0,
	0x9b, 0xf0, 0x2a, 0x3c, 0x0e, 0x2f, 0xb0, 0x9a, 0xb1, 0xf3, 0x57, 0xa9, 0x52, 0xef, 0xce, 0x77,
	0xfe, 0xe7, 0xcc, 0x39, 0x1f, 0x18, 0xb4, 0x48, 0x9c, 0xa2, 0xcc, 0x79, 0x8e, 0xaf, 0xc0, 0x24,
	0x8c, 0xc6, 0x84, 0xfd, 0x55, 0xb3, 0x8a, 0x23, 0x0b, 0xba, 0x75, 0x12, 0xdb, 0xca, 0x44, 0x99,
	0x1a, 0x44, 0x88, 0xf8, 0x0d, 0x0c, 0xb6, 0x65, 0xc2, 0xd9, 0x93, 0x1e, 0x08, 0x81, 0x16, 0x53,
	0x4e, 0x6d, 0x75, 0xd2, 0x9d, 0x1a, 0x44, 0xca, 0xf8, 0x47, 0xb8, 0xbc, 0x65, 0x9c, 0x26, 0xd9,
	0xbb, 0x7c, 0x1f, 0x88, 0x40, 0x2b, 0x69, 0xf4, 0xa1, 0x8d, 0x94, 0x32, 0xfa, 0x1c, 0xf4, 0xbb,
	0x9c, 0x96, 0xb1, 0xad, 0x4a, 0x65, 0x03, 0xf0, 0x15, 0x0c, 0xc3, 0x92, 0x66, 0x15, 0x8d, 0x78,
	0x92, 0x67, 0x7e, 0x8c, 0x46, 0xa0, 0x1e, 0x4a, 0xaa, 0x49, 0x8c, 0x63, 0x18, 0x34, 0x4d, 0x57,
	0x45, 0x9e, 0x55, 0x0c, 0xbd, 0x04, 0x83, 0x27, 0x29, 0xab, 0x38, 0x4d, 0x8b, 0xd6, 0xed, 0xa8,
	0x40, 0x13, 0xd0, 0xf8, 0x43, 0xc1, 0x64, 0x8d, 0x91, 0x3b, 0x70, 0x44, 0x68, 0x92, 0xbd, 0x0f,
	0x1f, 0x0a, 0x46, 0xa4, 0x45, 0xb4, 0xf1, 0x91, 0xee, 0x6a, 0x66, 0x77, 0x9b, 0x36, 0x24, 0xc0,
	0xff, 0xaa, 0x60, 0x1d, 0x1f, 0xf1, 0xac, 0x52, 0xed, 0x70, 0xd4, 0xb3, 0xe1, 0xc8, 0xe2, 0x4d,
	0xe6, 0x43, 0xb9, 0x34, 0x8f, 0xd9, 0xce, 0xd6, 0x9a, 0x72, 0x12, 0x20, 0x0c, 0x83, 0x94, 0x66,
	0xf5, 0x3b, 0x1a, 0xf1, 0xba, 0x64, 0xa5, 0xad, 0x4b, 0xe3, 0x99, 0x0e, 0x8d, 0xa1, 0x2f, 0xbf,
	0x2d, 0xca, 0x77, 0x76, 0x4f, 0xda, 0x0f, 0x58, 0x54, 0x12, 0x9d, 0xda, 0x17, 0x4d, 0x25, 0x21,
	0x23, 0x1b, 0x2e, 0xa2, 0x3c, 0x4d, 0x59, 0xc6, 0xed, 0xbe, 0x54, 0xef, 0x21, 0xfa, 0x06, 0xfa,
	0xbb, 0x3c, 0xa2, 0x62, 0xc0, 0xb6, 0x31, 0x51, 0xa6, 0xa6, 0x3b, 0x74, 0xc4, 0x63, 0x17, 0xad,
	0x92, 0x1c, 0xcc, 0xe8, 0x15, 0xf4, 0xf2, 0x9a, 0x17, 0x35, 0xb7, 0x61, 0xd2, 0x9d, 0x9a, 0xae,
	0x29, 0x1d, 0x97, 0x52, 0x45, 0x5a, 0x13, 0xfe, 0x5f, 0x81, 0x61, 0xbb, 0x27, 0xcf, 0x9a, 0x94,
	0x0b, 0xbd, 0x8a, 0x53, 0x5e, 0x57, 0xed, 0xb7, 0x8c, 0x9d, 0xb3, 0xe8, 0x06, 0xad, 0xa5, 0x07,
	0x69, 0x3d, 0xd1, 0x77, 0xa0, 0x0b, 0xa9, 0x19, 0xe6, 0xc8, 0x7d, 0xf1, 0x54, 0x08, 0x23, 0x8d,
	0x1f, 0xfe, 0x19, 0xcc, 0x93, 0x3c, 0xc8, 0x84, 0x8b, 0x4d, 0x70, 0x13, 0x2c, 0xb7, 0x81, 0xd5,
	0x11, 0x60, 0xe5, 0x05, 0x73, 0x3f, 0xf8, 0xcd, 0x52, 0x04, 0xd8, 0x12, 0x3f, 0x14, 0x40, 0x45,
	0x7d, 0xd0, 0xe6, 0xcb, 0xc0, 0xb3, 0xba, 0xf8, 0x0a, 0xe0, 0x98, 0x14, 0xf5, 0x40, 0x5d, 0xde,
	0x58, 0x1d, 0x64, 0x80, 0xee, 0x11, 0xb2, 0x24, 0x96, 0x82, 0x7f, 0x82, 0xd1, 0x71, 0x16, 0x9b,
	0x2c, 0x91, 0x5b, 0x9e, 0xd1, 0x94, 0xed, 0xb7, 0x5c, 0xc8, 0xe8, 0x4b, 0xe8, 0x55, 0x0f, 0xe9,
	0x5d, 0xbe, 0x6b, 0x17, 0xa3, 0x45, 0xf8, 0x87, 0xe6, 0x48, 0xda, 0x49, 0xd2, 0xec, 0x3d, 0x13,
	0x0b, 0x94, 0x26, 0x99, 0x8c, 0xd6, 0x89, 0x10, 0xa5, 0x86, 0xde, 0xcb, 0x48, 0xa1, 0xa1, 0xf7,
	0xf8, 0x1f, 0x05, 0xe0, 0x18, 0x77, 0xd8, 0x30, 0xe5, 0x64, 0xc3, 0x5e, 0x82, 0x51, 0x94, 0x2c,
	0x4a, 0x2a, 0xf1, 0xbd, 0x4d, 0xe8, 0x51, 0x81, 0x5e, 0x81, 0x56, 0x67, 0x09, 0x97, 0x63, 0x34,
	0xdd, 0x4b, 0xe7, 0xfc, 0x09, 0x44, 0x1a, 0xd1, 0x57, 0xa0, 0x97, 0xa2, 0x25, 0xb9, 0xa4, 0xa6,
	0x6b, 0x39, 0x8f, 0x5a, 0x25, 0x8d, 0x19, 0xaf, 0x60, 0x70, 0xba, 0x37, 0xcf, 0x3f, 0x73, 0x31,
	0x96, 0x98, 0x7d, 0x4c, 0xa2, 0xfd, 0x71, 0xb4, 0xe8, 0xdb, 0xbf, 0x1b, 0x4a, 0x6a, 0x4f, 0xf4,
	0xfc, 0xd7, 0x2e, 0xc1, 0x0c, 0xbd, 0xdb, 0x95, 0x47, 0x66, 0xe1, 0x86, 0x78, 0x96, 0x82, 0x5e,
	0xc0, 0x17, 0x73, 0xff, 0xfa, 0xda, 0x23, 0x5e, 0x10, 0xfa, 0xb3, 0xc5, 0xdb, 0x15, 0xf1, 0xd6,
	0x6b, 0x61, 0x52, 0x45, 0xe0, 0xcc, 0x27, 0xd7, 0x8b, 0xe5, 0xd6, 0xea, 0xa2, 0x01, 0xf4, 0x7f,
	0xdf, 0xdc, 0xfa, 0x73, 0x3f, 0xfc, 0xc3, 0xd2, 0xd0, 0x10, 0x8c, 0x85, 0x37, 0x7f, 0xbb, 0x0e,
	0x67, 0xa1, 0x67, 0xe9, 0x7b, 0xf8, 0xcb, 0xc2, 0x0f, 0x6e, 0xac, 0x9e, 0xfb, 0x9f, 0x02, 0xa6,
	0x9f, 0x71, 0x56, 0x66, 0x74, 0x37, 0x2b, 0x12, 0xf4, 0x35, 0x68, 0xa2, 0x21, 0xd4, 0x50, 0x47,
	0xcb, 0x67, 0xe3, 0xa1, 0x73, 0xca, 0x41, 0xb8, 0xf3, 0xbd, 0x82, 0xa6, 0xa0, 0xcb, 0x7d, 0x41,
	0x43, 0xe7, 0x94, 0x33, 0xc7, 0x23, 0xe7, 0x8c, 0xcf, 0x70, 0x07, 0xbd, 0x86, 0xfe, 0x9e, 0x5a,
	0x50, 0x33, 0xda, 0x13, 0xaa, 0x1c, 0x7f, 0xe6, 0x3c, 0xe6, 0x1d, 0x99, 0xfe, 0x0d, 0x58, 0x27,
	0x79, 0x7e, 0xfd, 0x93, 0x45, 0x1f, 0xd0, 0xa3, 0xd4, 0xe3, 0xd1, 0xf9, 0x51, 0xe0, 0xce, 0x5d,
	0x4f, 0x32, 0xc4, 0xeb, 0x4f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x97, 0xe1, 0x9b, 0xf5, 0x05,
	0x00, 0x00,
}
